---
title: "Isochrone"
author: "Leonard-Allen"
Last Update: 7/05/2022
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
    theme: readable
  pdf_document:
    toc: yes
    toc_depth: '4'
colorlinks: yes
urlcolor: blue
linkcolor: blue
citecolor: blue
anchorcolor: blue
toccolor: blue
fontsize: 12pt
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Loading my packages

```{r}
#setwd("C:/Users/Leo Allen/Desktop/Isochrones/isochrones")  #set the working directory

library(RColorBrewer)
library(traveltime)
library(tidyverse)
library(tidycensus)
library(sf)
library(osmdata)
library(leaflet)
library(sp)
library(purrr)
library(mapview)
library(osrm)
library(rmapzen)
library(rgdal)
library(ggplot2)
library(scales)
library(nycflights13)
library(readxl)
library(rgdal)
```

#TRAVELTIME; install this in R console (NOT R STUDIO)!!!
#Install the latest version of this package by entering the following in R:
#install.packages("remotes")
#remotes::install_github("tlorusso/traveltimeR")

```{r}
#install.packages("remotes")
#remotes::install_github("tlorusso/traveltimeR")
```



#getting population and maps of surrounding of page from acs
#I registered for my personal key from the website

##############
#travel time, I did this once to generate center RDS file
#to get the api and the id I visited the website and signed up:
#https://traveltime.com/docs/api/overview/getting-keys

```{r}

YourAPIKey <- "eb02516c05b7d10f8e03477312b537fa"
YourAppId <- "acfb52eb"

```


#Error Check
```{r eval=FALSE, include=FALSE}
# retrieve data via request 

# The following transport modes are supported:

# "cycling"", "cycling_ferry", "driving", "driving+train", "driving_ferry", "public_transport", 
# "walking", "walking+coach", "walking_bus", "walking_ferry" or "walking_train".

# how far can you go by public transport within 30 minutes?

# We can make some excel file with the coordinates of richmond so we can easily select it within the traveltime_map function call.


traveltime30 <- traveltime_map(appId="YourAppId",
               apiKey="YourAPIKey",
              location=c(47.378610,8.54000),
               traveltime=1800,
               type="public_transport",
               departure="2018-11-15T08:00:00+01:00")

# ... and within 60 minutes?
traveltime60 <- traveltime_map(appId="YourAppId",
               apiKey="YourAPIKey",
               location=c(47.378610,8.54000),
               traveltime=3600,
               type="public_transport",
               departure="2012-11-15T08:00:00+01:00")

```


# Checks: latitude, Longitude, seconds
# Also, departure time must lie in the future.

```{r}
# retrieve data via request 

# The following transport modes are supported:

# "cycling"", "cycling_ferry", "driving", "driving+train", "driving_ferry", "public_transport", 
# "walking", "walking+coach", "walking_bus", "walking_ferry" or "walking_train".

# how far can you go by public transport within 30 minutes?

# Travel times for 2021
traveltime30_2021 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=1800,
              type="driving",
              departure="2021-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))
traveltime45_2021 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=2700,
              type="driving",
              departure="2021-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))
traveltime60_2021 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=3600,
              type="driving",
              departure="2021-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))


# Travel times for 2020

traveltime30_2020 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=1800,
              type="driving",
              departure="2020-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))
traveltime45_2020 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=2700,
              type="driving",
              departure="2020-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))
traveltime60_2020 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=3600,
              type="driving",
              departure="2020-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))
traveltime15_2021 <- traveltime_map(appId=YourAppId,
              apiKey=YourAPIKey,
              location=c(37.534379575044426,-77.44071077873014),
              traveltime=900,
              type="driving",
              departure="2021-07-07T08:00:00+01:00") %>%
  st_set_crs(st_crs("EPSG:4326"))
```

```{r eval=FALSE, include=FALSE}
# Importing the data with centroid coordinates
aoi_boundary_POW <- st_read("Powhatan_Parcel_Data/Powhatan_2021_Centroid/PowReduTaxParcels2021.shp") %>% st_transform(crs = st_crs("EPSG:4326"))

# Creating a dataframe and shape object of the parcel centroids
centroid_coords <- data.frame(lat = aoi_boundary_POW$centroid_x, lng = aoi_boundary_POW$centroid_y)
centroid_points <- st_as_sf(SpatialPoints(coords = centroid_coords)) %>% st_set_crs(st_crs("EPSG:4326"))

# Seeing whether or not the travel time's are in the boundary at a given time
traveltime_categories <- c("Within 30 Minutes", "Within 45 Minutes", "Within 60 Minutes", "More than 60 Minutes")
aoi_boundary_POW$travel <- rep("stale", nrow(aoi_boundary_POW))

# Don't run this too often, it's long
for(i in 1:nrow(aoi_boundary_POW)){
  if(st_intersects(traveltime30_2021, centroid_points$geometry[i], sparse=FALSE)){
    aoi_boundary_POW$travel[i] = traveltime_categories[1]
  }
  else if(st_intersects(traveltime45_2021, centroid_points$geometry[i], sparse=FALSE)){
    aoi_boundary_POW$travel[i] = traveltime_categories[2]
  }
  else if(st_intersects(traveltime60_2021, centroid_points$geometry[i], sparse=FALSE)){
    aoi_boundary_POW$travel[i] = traveltime_categories[3]
  }
  else {
    aoi_boundary_POW$travel[i] = traveltime_categories[4]
  }
}
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "More than 60 Minutes", "4")
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "Within 60 Minutes", "3")
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "Within 45 Minutes", "2")
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "Within 30 Minutes", "1")

mypalette <- colorBin(palette = "viridis", as.numeric(aoi_boundary_POW$travel), bins = 5)
sorted_colors <- c("#440154", "#2A788E", "#7AD151", "#FDE725")

# First provider shape file of the county boundary, so first addPolygons
map <-leaflet() %>%
  addTiles() %>%
  addProviderTiles("Esri") %>%  
  
  addPolygons(data=aoi_boundary_POW$geometry, color = "black",
              fillColor = mypalette(as.numeric(aoi_boundary_POW$travel)),
              smoothFactor = 0.2, fillOpacity=.6, weight = 1,stroke = T) %>%
  
  addPolygons(data = traveltime30_2021 , color = "Yellow",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .1, 
              group = "Within 30") %>%
  addPolygons(data = traveltime45_2021 , color = "Orange",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .1,
              group = "Within 45") %>%
  addPolygons(data = traveltime60_2021 , color = "Red",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .2,
              group = "Within 60") %>%
  addPolygons(data = traveltime15_2021 , color = "Red",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .2,
              group = "Within 15") %>%
  addCircleMarkers(lat = 37.534379575044426, lng = -77.44071077873014) %>%
  addLegend("bottomright", 
            colors= sorted_colors,
            labels = traveltime_categories,
            title = "Travel Times in Minutes (2021)", 
            opacity = 1) %>%
  addLayersControl(
    baseGroups=c("Within 15", "Within 30", "Within 45", "Within 60"),
    position = "bottomleft",
    options = layersControlOptions(collapsed = FALSE)
  )
  
map
```

```{r eval=FALSE, include=FALSE}
# Importing the data with centroid coordinates
aoi_boundary_POW <- st_read("Powhatan_Parcel_Data/Powhatan_2021_Centroid/PowReduTaxParcels2021.shp") %>% st_transform(crs = st_crs("EPSG:4326"))

# Creating a dataframe and shape object of the parcel centroids
centroid_coords <- data.frame(lat = aoi_boundary_POW$centroid_x, lng = aoi_boundary_POW$centroid_y)
centroid_points <- st_as_sf(SpatialPoints(coords = centroid_coords)) %>% st_set_crs(st_crs("EPSG:4326"))

# Seeing whether or not the travel time's are in the boundary at a given time
traveltime_categories <- c("Within 30 Minutes", "Within 45 Minutes", "Within 60 Minutes", "More than 60 Minutes")
aoi_boundary_POW$travel20 <- rep("stale", nrow(aoi_boundary_POW))

# Don't run this too often, it's long
for(i in 1:nrow(aoi_boundary_POW)){
  if(st_intersects(traveltime30_2020, centroid_points$geometry[i], sparse=FALSE)){
    aoi_boundary_POW$travel[i] = traveltime_categories[1]
  }
  else if(st_intersects(traveltime45_2020, centroid_points$geometry[i], sparse=FALSE)){
    aoi_boundary_POW$travel[i] = traveltime_categories[2]
  }
  else if(st_intersects(traveltime60_2020, centroid_points$geometry[i], sparse=FALSE)){
    aoi_boundary_POW$travel[i] = traveltime_categories[3]
  }
  else {
    aoi_boundary_POW$travel[i] = traveltime_categories[4]
  }
}
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "More than 60 Minutes", "4")
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "Within 60 Minutes", "3")
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "Within 45 Minutes", "2")
aoi_boundary_POW$travel <- str_replace(aoi_boundary_POW$travel, "Within 30 Minutes", "1")

mypalette <- colorBin(palette = "viridis", as.numeric(aoi_boundary_POW$travel), bins = 5)
sorted_colors <- c("#440154", "#2A788E", "#7AD151", "#FDE725")

# First provider shape file of the county boundary, so first addPolygons
map <-leaflet() %>%
  addTiles() %>%
  addProviderTiles("Esri") %>%  
  
  addPolygons(data=aoi_boundary_POW$geometry, color = "black",
              fillColor = mypalette(as.numeric(aoi_boundary_POW$travel)),
              smoothFactor = 0.2, fillOpacity=.6, weight = 1,stroke = T) %>%
  
  addPolygons(data = traveltime30_2020 , color = "Orange",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .1, 
              group = "Within 30") %>%
  addPolygons(data = traveltime45_2020 , color = "Yellow",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .1,
              group = "Within 45") %>%
  addPolygons(data = traveltime60_2020 , color = "Red",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .2,
              group = "Within 60") %>%
  addPolygons(data = traveltime15_2020 , color = "Red",
               opacity = 1, weight = 2, fillColor = "white",fillOpacity = .2,
              group = "Within 15") %>%
  addCircleMarkers(lat = 37.534379575044426, lng = -77.44071077873014) %>%
  addLegend("bottomright", 
            colors= sorted_colors,
            labels = traveltime_categories,
            title = "Travel Times in Minutes (2020)", 
            opacity = 1) %>%
  addLayersControl(
    baseGroups=c("Within 30", "Within 45", "Within 60"),
    position = "bottomleft",
    options = layersControlOptions(collapsed = FALSE)
  )
  
map
```


```{r}
st_write(traveltime15_2021, "15MinuteTravelTime.shp")
st_write(traveltime30_2021, "30MinuteTravelTime.shp")
st_write(traveltime45_2021, "45MinuteTravelTime.shp")
st_write(traveltime60_2021, "60MinuteTravelTime.shp")
```




# Useful link

[Website](https://tlorusso.github.io/traveltime/vignette.html#:~:text=traveltime%20%2D%20a%20Traveltime%20API%20Wrapper%20for%20R,-1%20Querying%20the&text=The%20isochrones%20display%20how%20far,modes%20of%20transport%20are%20supported.&text=For%20non%2Dcommercial%20use%20the,max%2030%20queries%20per%20min)